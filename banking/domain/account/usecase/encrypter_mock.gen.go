// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"github.com/thalissonfelipe/banking/banking/domain/encrypter"
	"sync"
)

// Ensure, that EncrypterMock does implement encrypter.Encrypter.
// If this is not the case, regenerate this file with moq.
var _ encrypter.Encrypter = &EncrypterMock{}

// EncrypterMock is a mock implementation of encrypter.Encrypter.
//
// 	func TestSomethingThatUsesEncrypter(t *testing.T) {
//
// 		// make and configure a mocked encrypter.Encrypter
// 		mockedEncrypter := &EncrypterMock{
// 			CompareHashAndSecretFunc: func(hashedSecret []byte, secret []byte) error {
// 				panic("mock out the CompareHashAndSecret method")
// 			},
// 			HashFunc: func(secret string) ([]byte, error) {
// 				panic("mock out the Hash method")
// 			},
// 		}
//
// 		// use mockedEncrypter in code that requires encrypter.Encrypter
// 		// and then make assertions.
//
// 	}
type EncrypterMock struct {
	// CompareHashAndSecretFunc mocks the CompareHashAndSecret method.
	CompareHashAndSecretFunc func(hashedSecret []byte, secret []byte) error

	// HashFunc mocks the Hash method.
	HashFunc func(secret string) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompareHashAndSecret holds details about calls to the CompareHashAndSecret method.
		CompareHashAndSecret []struct {
			// HashedSecret is the hashedSecret argument value.
			HashedSecret []byte
			// Secret is the secret argument value.
			Secret []byte
		}
		// Hash holds details about calls to the Hash method.
		Hash []struct {
			// Secret is the secret argument value.
			Secret string
		}
	}
	lockCompareHashAndSecret sync.RWMutex
	lockHash                 sync.RWMutex
}

// CompareHashAndSecret calls CompareHashAndSecretFunc.
func (mock *EncrypterMock) CompareHashAndSecret(hashedSecret []byte, secret []byte) error {
	if mock.CompareHashAndSecretFunc == nil {
		panic("EncrypterMock.CompareHashAndSecretFunc: method is nil but Encrypter.CompareHashAndSecret was just called")
	}
	callInfo := struct {
		HashedSecret []byte
		Secret       []byte
	}{
		HashedSecret: hashedSecret,
		Secret:       secret,
	}
	mock.lockCompareHashAndSecret.Lock()
	mock.calls.CompareHashAndSecret = append(mock.calls.CompareHashAndSecret, callInfo)
	mock.lockCompareHashAndSecret.Unlock()
	return mock.CompareHashAndSecretFunc(hashedSecret, secret)
}

// CompareHashAndSecretCalls gets all the calls that were made to CompareHashAndSecret.
// Check the length with:
//     len(mockedEncrypter.CompareHashAndSecretCalls())
func (mock *EncrypterMock) CompareHashAndSecretCalls() []struct {
	HashedSecret []byte
	Secret       []byte
} {
	var calls []struct {
		HashedSecret []byte
		Secret       []byte
	}
	mock.lockCompareHashAndSecret.RLock()
	calls = mock.calls.CompareHashAndSecret
	mock.lockCompareHashAndSecret.RUnlock()
	return calls
}

// Hash calls HashFunc.
func (mock *EncrypterMock) Hash(secret string) ([]byte, error) {
	if mock.HashFunc == nil {
		panic("EncrypterMock.HashFunc: method is nil but Encrypter.Hash was just called")
	}
	callInfo := struct {
		Secret string
	}{
		Secret: secret,
	}
	mock.lockHash.Lock()
	mock.calls.Hash = append(mock.calls.Hash, callInfo)
	mock.lockHash.Unlock()
	return mock.HashFunc(secret)
}

// HashCalls gets all the calls that were made to Hash.
// Check the length with:
//     len(mockedEncrypter.HashCalls())
func (mock *EncrypterMock) HashCalls() []struct {
	Secret string
} {
	var calls []struct {
		Secret string
	}
	mock.lockHash.RLock()
	calls = mock.calls.Hash
	mock.lockHash.RUnlock()
	return calls
}
